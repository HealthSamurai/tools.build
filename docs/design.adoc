= tools.build Design FAQ
Alex Miller
2020-10-07
:type: guides
:toc: macro

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

toc::[]

This discusses various design questions and decisions around tools.build for future reference.

== Basis

=== What is the basis and where does it come from?

The basis (or runtime basis) is a Clojure program execution context as https://clojure.github.io/tools.deps.alpha/clojure.tools.deps.alpha-api.html#clojure.tools.deps.alpha/calc-basis[produced] by https://github.com/clojure/tools.deps.alpha[tools.deps]. It is a Clojure map that contains the following keys:

* `:resolve-args` - modifiers to `resolve-deps`
* `:classpath-args` - modifiers to `make-classpath`
* `:libs` - the lib map, a map of lib name to lib info for all included libraries
* `:classpath` - the classpath map, a map of file path to source
* `:classpath-roots` - the classpath paths in classpath order

In tools.build, the basis is computed based on the project deps.edn. The user deps.edn is not included (equivalent to `-Srepro`).

== Parameters

=== What are the types of parameters and how do they pass through a build?

The build is invoked with a set of build parameters that will flow through each task. Additionally, each task may have additional per-task parameters that are merged over the build parameters and may return parameters that will be merged into the parameters seen by the next task.

=== Why do some parameter names end in `>`?

Parameter names ending in `>`, like `:build/out>` expect to have as the value a parameter name that will be returned from the task. For example, the `process` task will return stdout in a return parameter named by `:build/out>`. In this way, tasks can pass values from one task to another based on a common name the user has chosen.

== Tasks

=== How are tasks resolved?

There are two type of tasks - built-in and user-provided. Built-in tasks are unqualified (like `clean`) and will be resolved by tools.build automatically. User-provided tasks must be fully-qualified symbols that resolve to a task function.

=== How do tasks work together to accomplish a goal?

Generally, builds are designed to produce one or more output artifacts. tools.build tasks generally move and/or create files in working directories under `:build/target-dir` then create artifacts based on the contents of those directories. For example, the `:build/class-dir` is where files will be collected to be jar'ed (compiled class files, clojure source files, resource files, pom files, etc). 
=== When should I use per-task parameters?

In general, tasks share some common parameters, like `:build/class-dir` where files to be jar'ed are collected (so `javac`, `compile-clj`, and `copy` all add files to this directory and `jar` reads from it to produce a jar).

If you are producing multiple jars, or need to perform the same step multiple times, you may need to override task parameters on a per-task basis. For example, if you wanted to create both a compiled jar and a source-only jar, that could be done by using a custom `:build/class-dir` for all of the tasks to build one of those jars.

== Paths

=== How are paths handled in a build?

The `build` function takes two important directories - the `:build/project-dir` (the "source" where data is only read) and `:build/output-dir` (the "target" where things are written). By default, these directories are the same, which allows artifacts to be written into the project if necessary, but must intermediate work state occurs in the `:build/target-dir`, resolved relative to `:build/output-dir`, and typically the `target` directory.

Most tasks work with directories and files and will resolve the paths of those either in terms of `:build/project-dir` or `:build/output-dir`. Task docs should specify how any path attribute is resolved, usually in terms of `:build/project-dir` (for project inputs), `:build/output-dir` (for outputs), or occasionally `:build/target-dir` (for intermediate working areas).

== Builds

=== When should a build produce multiple artifacts vs having multiple builds that each produce one artifact?

Builds should reflect the granularity of use. If your project always needs to produce 3 artifacts, that should be one build. If instead it sometimes produces one artifact (your library jar) and sometimes a different artifact (zip of docs), those should be two builds. Currently, there is no explicit support for composing builds together but that is something that may be added in the future.


