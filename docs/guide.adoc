= tools.build Guide
Alex Miller
2020-06-30
:type: guide
:toc: macro

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

toc::[]

== Rationale

The tools.deps library and Clojure CLI tools provide support for building classpaths with dependencies, including source-based dependencies (local- and git-based). However, some libraries require build steps for compilation, resource file transformation, or artifact building.

Builds are themselves programs and tools.build is a library for writing builds in terms of tasks driven by data in the deps.edn file. Many common built-in tasks are provided but the system is also open for extension and combination with other tools as needed. For the common case, support is available for invoking builds from the command line with the Clojure CLI tools.

== Getting started

tools.build is a library for writing Clojure build programs. It depends on tools.deps and the Clojure tools. These related pages may be of use for background:

* https://clojure.org/guides/getting_started[Getting Started guide] - for installing the Clojure tools
* https://clojure.org/guides/deps_and_cli[Deps and CLI guide] - using the Clojure tools
* https://clojure.org/reference/deps_and_cli[Deps and CLI reference] - more detailed reference info about the Clojure tools
* <<xref#reference,tools.build reference>>

== Installing tools.build as a Clojure tool

Intalling tools.build as an alias in `~/.clojure/deps.edn` allows it to be used from any project. Add an alias as follows:

[source,clojure]
----
{...
 :aliases
 {:build
  {:replace-deps {org.clojure/tools.build {:git/url "git@github.com:cognitect-labs/tools.build.git"
                                           :sha "<SHA>"}
                  org.slf4j/slf4j-nop {:mvn/version "1.7.25"}}
   :exec-fn clojure.tools.build/build}}}
----

You can find the latest sha for tools.build with:

[source,shell]
----
git ls-remote git@github.com:cognitect-labs/tools.build.git refs/heads/master
----

__Note: this will be different once public and released.__

== A simple build

A build is defined in terms of tasks and params. The tasks are executed sequentially and params can be specified either for all tasks or specific tasks. Task-specific parameters override the build parameters.

The easiest way to define params and tasks is as data in a deps.edn alias. deps.edn aliases are names for data structures, here data to be conveyed to the build at runtime. A deps.edn file defining config data named `:jar-config`:

[source,clojure]
----
{:paths ["src"]
 :deps {}

 :aliases
 {:jar-config
  {:tasks [[dirs] [clean] [copy] [jar]]
   :params
   {:build/lib myorg/mylib
    :build/version "1.2.3"
    :build/copy-specs [{:from "src"}]}}}}
----

The `:jar-config` alias is not special, it can be named anything and there can be many build definitions in the aliases.

Each task is a vector consisting of a task name and an optional task-specific parameter map (none here). Built-in tasks are unqualified, custom tasks must be qualified and refer to the function implementing the task.

The params map is passed to the build, which adds some params and flows it through each task. Tasks can return new params to add to the flow. Generally, tasks should emit parameters that add to the build parameter map, rather than override values, although this is allowed. Additionally, each parameter value may be the name of another parameter OR an alias in deps.edn to find the value.

In this example, there are four tasks that work together to create a basic Clojure source jar. The tasks work as follows:

* `dirs` - uses `:build/output-dir`, `:build/lib`, `:build/version` etc to initialize many output directories and files which are emitted to the build parameters
* `clean` - removes the target directory (this is one of the directories defined by `dirs`)
* `copy` - copies clojure source files from the project directory to the jar assembly directory
* `jar` - creates a jar from the jar assembly directory and writes it to the target directory

image::build-example.png[]

== Running the build

The final missing piece is to execute the build using the config. The `clj -X` switch is used to execute a function that takes a map, whose data can be pulled from a deps.edn alias. 

The deps.edn will contains the config and the jar build:

[source,clojure]
----
{:paths ["src"]
 :deps {}

 :aliases
 {:jar-config
  {:tasks [[dirs] [clean] [copy] [jar]]
   :params
   {:build/lib myorg/mylib
    :build/version "1.2.3"
    :build/copy-specs [{:from "src"}]}}

  :jar
  {:exec-args :jar-config}}}
----

The simpler command is then:

[source,shell]
----
clj -X:build:jar
----

== Overriding params at the command line

The `-X` switch also provides the abillity to override params at the command line, for example to specify a new version to replace the value at the nested path `[:params :build/version]`:

[source,shell]
----
clj -X:build:jar '[:params :build/version]' '"1.3.0"'
----

== Using aliases in params

As mentioned above, param values can be alias names in deps.edn. Rather than declare `"src"` twice in :paths and the copy task specs, create an alias defining the Clojure source paths and modify deps.edn as follows:

[source,clojure]
----
{:paths [:clj-paths]
 :deps {}

 :aliases
 {:clj-paths ["src"]
  :jar-config
  {:tasks [[dirs] [clean] [copy] [jar]]
   :params
   {:build/lib myorg/mylib
    :build/version "1.2.3"
    :build/copy-specs [{:from :clj-paths}]}}
  :jar
  {:exec-args :jar-config}}}
----

This build is functionally equivalent and it may be useful to use `:clj-paths` elsewhere.

== Build customization

Quite a bit of customization can be done simply with the built-in tasks, including param overrides on a per-task basis. Beyond that, custom tasks can be provided and added to the build classpath. Refer to them by their qualified name in the task list and they will be automatically loaded.

And finally, builds may grow complex enough that they need to be combined with code, either before or after the build. To do so, write a program that uses tools.build as a library and set up to run it from deps.edn. All of these approaches can use data from deps.edn aliases so builds can grow in complexity over time while still using the same set of tasks and params.
